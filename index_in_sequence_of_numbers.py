print('Программа получает на вход числовой список, проверяет его и запрашивает число из списка для того, чтобы вывести его индекс')
sequence_1 = str(input("Введите последовательность неотрицательных чисел через пробел: "))
number_1 = float(input("Введите число, чтобы узнать его (или ближайшего) индекс в списке: "))


# проверка и получение списка из чисел
def check_symbols(sequence):
    """Функция проверяет последовательность на наличие чисел, точки и пробела
    и запрашивает новую последовательность до тех пор, пока новая последовательность не
    будет соответствовать условию"""
    for i in sequence:
        if i not in '1234567890. ':
            # если в последовательности есть хоть один символ отличный от цифр, точки и пробела,
            # то выполняется нижний блок
            # последовательность заново запрашивается
            sequence = str(input("Введите корректную последовательность из чисел: "))
            # преобразование локальных переменных в глобальные
            global probably_valid_sequence
            global number_1
            # если новая последовательность валидная, то к этому блоку возвращаться
            # будет не нужно, поэтому запишем новую последовательность sequence
            # в новую переменную probably_valid_sequence
            probably_valid_sequence = sequence
            # получаем новое число, индекс которого нужно узнать
            number_1 = float(input("Введите число, чтобы узнать его (или ближайшего) индекс в списке: "))
            # возвращаемся в начало функции при помощи рекурсии
            check_symbols(sequence)
            # в break нет нужды
            # break
    # если последовательность запрашивалась повторно, то выводится новая проверенная и валидная
    if 'probably_valid_sequence' in locals():
        return probably_valid_sequence
    # если блок проверки был пройден успешно изначально, то выводится исходная последовательность
    else:
        return sequence


# копируем проверенную последовательность в новую переменную
sequence_2 = check_symbols(sequence_1)


# преобразование в список и проверка на наличие чисел
def catch_exception(sequence):
    """Функция пытается создать список по пробелам из переданной
    последовательности вещественных чисел"""
    # попытка создать список из переданной последовательности по пробелам
    try:
        b = list(map(float, sequence.split()))
    except ValueError as error:
        print('Последовательность должна соответствовать примеру: -1.0 2 3.0', '"', error, '"')
    else:
        # b = list(map(float, sequence.split()))
        return b


# копируем полученный список в новую переменную
sequence_3 = catch_exception(sequence_2)


# сортировка по возрастанию
def sorting(sequence):
    sequence.sort(key=None, reverse=False)
    return sequence


# копируем отсортированный список в новую переменную
sequence_4 = sorting(sequence_3)


# для применения двоичного поиска структура должна быть отсортирована
def binary_search(sequence, element, left, right):
    """Функция двоичного (бинарного) поиска выдает индекс списка, значение
    элемента которого совпадает со значением, передаваемого в функцию.
    Список делится пополам, половины снова делятся пополам и т.д., пока
    элемент не окажется в середине какой-либо половины"""
    # левый индекс списка не может быть меньше правого
    if left > right:
        return False

    # деление списка пополам
    middle = (right + left) // 2
    # если средний индекс списка имеет элемент, значение которого совпадает
    # со значением передаваемого в функцию
    if sequence[middle] == element:
        # выводится этот индекс
        return middle
    # если нет, то проверяем в левой части, передав правую границу на единицу меньше
    # т.е. исключаем уже проверенный элемент и проверяем новую половину
    elif element < sequence[middle]:
        return binary_search(sequence, element, left, middle-1)
    # если нет, то проверяем в правой части, передав левую границу на единицу больше
    # т.е. исключаем уже проверенный элемент и проверяем новую половину
    else:
        return binary_search(sequence, element, middle+1, right)


# передаем в функцию бинарного поиска отсортированный список, число последовательности,
# индекс которой нужно узнать, левую границу списка и правую границу списка
# т.к. список итерируется с 0 элемента, то его длина будет больше индекса
# последнего итерируемого элемента, поэтому используется (len(sequence_4)-1)
sequence_5 = binary_search(sequence_4, number_1, 0, (len(sequence_4)-1))

# вывод результатов
print('\n', 'Полученный список:       ', catch_exception(sequence_2))
print('\n', 'Список после сортировки: ', sequence_4, '\n')
if sequence_5:
    print(f' Номер позиции элемента {number_1} в сортированном списке (начиная с 0),\n',
          f' составляет: {sequence_5}')
else:
    print(f'Ошибка: число {number_1} меньше {sequence_4[0]} или больше {sequence_4[len(sequence_4)-1]}')

# следует учесть, что если в списке количество одинаковых элементов = 2, индекс которых пытаемся найти,
# то результат будет непредсказуемым
# если количество > 2, то
# при четном списке - выводится индекс левого элемента
# при нечетном списке - индекс правого элемента
